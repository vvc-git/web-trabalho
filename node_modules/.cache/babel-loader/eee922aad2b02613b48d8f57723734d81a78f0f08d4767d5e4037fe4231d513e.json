{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 9,\n  EQUAL: 8,\n  STARTS_WITH: 7,\n  WORD_STARTS_WITH: 6,\n  STRING_CASE: 5,\n  STRING_CASE_ACRONYM: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nvar caseRankings = {\n  CAMEL: 0.8,\n  PASCAL: 0.6,\n  KEBAB: 0.4,\n  SNAKE: 0.2,\n  NO_CASE: 0\n};\nmatchSorter.rankings = rankings;\nmatchSorter.caseRankings = caseRankings;\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // not performing any search/sort if value(search term) is empty\n  if (!value) return items;\n  var _options = options,\n    keys = _options.keys,\n    _options$threshold = _options.threshold,\n    threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(sortRankedItems).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n  function reduceItemsToRanked(matches, item, index) {\n    var _getHighestRanking = getHighestRanking(item, keys, value, options),\n      rankedItem = _getHighestRanking.rankedItem,\n      rank = _getHighestRanking.rank,\n      keyIndex = _getHighestRanking.keyIndex,\n      _getHighestRanking$ke = _getHighestRanking.keyThreshold,\n      keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;\n    if (rank >= keyThreshold) {\n      matches.push({\n        rankedItem: rankedItem,\n        item: item,\n        rank: rank,\n        index: index,\n        keyIndex: keyIndex\n      });\n    }\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedItem: item,\n      rank: getMatchRanking(item, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n      rankedItem = _ref2.rankedItem,\n      keyIndex = _ref2.keyIndex,\n      keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n      attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedItem = rankedItem;\n    var minRanking = attributes.minRanking,\n      maxRanking = attributes.maxRanking,\n      threshold = attributes.threshold;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedItem = itemValue;\n    }\n    return {\n      rankedItem: newRankedItem,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  /* eslint complexity:[2, 12] */\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n  var caseRank = getCaseRanking(testString);\n  var isPartial = isPartialOfCase(testString, stringToRank, caseRank);\n  var isCasedAcronym = isCaseAcronym(testString, stringToRank, caseRank); // Lower casing before further comparison\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL + caseRank;\n  } // starts with\n\n  if (testString.indexOf(stringToRank) === 0) {\n    return rankings.STARTS_WITH + caseRank;\n  } // word starts with\n\n  if (testString.indexOf(\" \" + stringToRank) !== -1) {\n    return rankings.WORD_STARTS_WITH + caseRank;\n  } // is a part inside a cased string\n\n  if (isPartial) {\n    return rankings.STRING_CASE + caseRank;\n  } // is acronym for a cased string\n\n  if (caseRank > 0 && isCasedAcronym) {\n    return rankings.STRING_CASE_ACRONYM + caseRank;\n  } // contains\n\n  if (testString.indexOf(stringToRank) !== -1) {\n    return rankings.CONTAINS + caseRank;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n  if (getAcronym(testString).indexOf(stringToRank) !== -1) {\n    return rankings.ACRONYM + caseRank;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score base on the case of the testString\n * @param {String} testString - the string to test against\n * @returns {Number} the number of the ranking,\n * based on the case between 0 and 1 for how the testString matches the case\n */\n\nfunction getCaseRanking(testString) {\n  var containsUpperCase = testString.toLowerCase() !== testString;\n  var containsDash = testString.indexOf('-') >= 0;\n  var containsUnderscore = testString.indexOf('_') >= 0;\n  if (!containsUpperCase && !containsUnderscore && containsDash) {\n    return caseRankings.KEBAB;\n  }\n  if (!containsUpperCase && containsUnderscore && !containsDash) {\n    return caseRankings.SNAKE;\n  }\n  if (containsUpperCase && !containsDash && !containsUnderscore) {\n    var startsWithUpperCase = testString[0].toUpperCase() === testString[0];\n    if (startsWithUpperCase) {\n      return caseRankings.PASCAL;\n    }\n    return caseRankings.CAMEL;\n  }\n  return caseRankings.NO_CASE;\n}\n/**\n * Returns whether the stringToRank is one of the case parts in the testString (works with any string case)\n * @example\n * // returns true\n * isPartialOfCase('helloWorld', 'world', caseRankings.CAMEL)\n * @example\n * // returns false\n * isPartialOfCase('helloWorld', 'oworl', caseRankings.CAMEL)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Number} caseRanking - the ranking score based on case of testString\n * @returns {Boolean} whether the stringToRank is one of the case parts in the testString\n */\n\nfunction isPartialOfCase(testString, stringToRank, caseRanking) {\n  var testIndex = testString.toLowerCase().indexOf(stringToRank.toLowerCase());\n  switch (caseRanking) {\n    case caseRankings.SNAKE:\n      return testString[testIndex - 1] === '_';\n    case caseRankings.KEBAB:\n      return testString[testIndex - 1] === '-';\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      return testIndex !== -1 && testString[testIndex] === testString[testIndex].toUpperCase();\n    default:\n      return false;\n  }\n}\n/**\n * Check if stringToRank is an acronym for a partial case\n * @example\n * // returns true\n * isCaseAcronym('super_duper_file', 'sdf', caseRankings.SNAKE)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the acronym to test\n * @param {Number} caseRank - the ranking of the case\n * @returns {Boolean} whether the stringToRank is an acronym for the testString\n */\n\nfunction isCaseAcronym(testString, stringToRank, caseRank) {\n  var splitValue = null;\n  switch (caseRank) {\n    case caseRankings.SNAKE:\n      splitValue = '_';\n      break;\n    case caseRankings.KEBAB:\n      splitValue = '-';\n      break;\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      splitValue = /(?=[A-Z])/;\n      break;\n    default:\n      splitValue = null;\n  }\n  var splitTestString = testString.split(splitValue);\n  return stringToRank.toLowerCase().split('').reduce(function (correct, char, charIndex) {\n    var splitItem = splitTestString[charIndex];\n    return correct && splitItem && splitItem[0].toLowerCase() === char;\n  }, true);\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index; j < string.length; j++) {\n      var stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (var i = 1; i < stringToRank.length; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\nfunction sortRankedItems(a, b) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRankedItem = a.rankedItem,\n    aRank = a.rank,\n    aKeyIndex = a.keyIndex;\n  var bRankedItem = b.rankedItem,\n    bRank = b.rank,\n    bKeyIndex = b.keyIndex;\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // localeCompare returns 0 if both values are equal,\n      // so we rely on JS engines stably sorting the results\n      // (de facto, all modern engine do this).\n      return String(aRankedItem).localeCompare(bRankedItem);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n  var value;\n  if (typeof key === 'function') {\n    value = key(item); // eslint-disable-next-line no-negated-condition\n  } else if (key.indexOf('.') !== -1) {\n    // handle nested keys\n    value = key.split('.').reduce(function (itemObj, nestedKey) {\n      return itemObj ? itemObj[nestedKey] : null;\n    }, item);\n  } else {\n    value = item[key];\n  } // concat because `value` can be a string or an array\n  // eslint-disable-next-line\n\n  return value != null ? [].concat(value) : null;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param {Object} item - the item from which the values will be retrieved\n * @param {Array} keys - the keys to use to retrieve the values\n * @return {Array} objects with {itemValue, attributes}\n */\n\nfunction getAllValuesToRank(item, keys) {\n  return keys.reduce(function (allVals, key) {\n    var values = getItemValues(item, key);\n    if (values) {\n      values.forEach(function (itemValue) {\n        allVals.push({\n          itemValue: itemValue,\n          attributes: getKeyAttributes(key)\n        });\n      });\n    }\n    return allVals;\n  }, []);\n}\n/**\n * Gets all the attributes for the given key\n * @param {Object|String} key - the key from which the attributes will be retrieved\n * @return {Object} object containing the key's attributes\n */\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    key = {\n      key: key\n    };\n  }\n  return _extends({\n    maxRanking: Infinity,\n    minRanking: -Infinity\n  }, key);\n}\nexport default matchSorter;\nexport { rankings };","map":{"version":3,"names":["_extends","removeAccents","rankings","CASE_SENSITIVE_EQUAL","EQUAL","STARTS_WITH","WORD_STARTS_WITH","STRING_CASE","STRING_CASE_ACRONYM","CONTAINS","ACRONYM","MATCHES","NO_MATCH","caseRankings","CAMEL","PASCAL","KEBAB","SNAKE","NO_CASE","matchSorter","items","value","options","_options","keys","_options$threshold","threshold","matchedItems","reduce","reduceItemsToRanked","sort","sortRankedItems","map","_ref","item","matches","index","_getHighestRanking","getHighestRanking","rankedItem","rank","keyIndex","_getHighestRanking$ke","keyThreshold","push","getMatchRanking","valuesToRank","getAllValuesToRank","_ref2","_ref3","i","itemValue","attributes","newRank","newRankedItem","minRanking","maxRanking","testString","stringToRank","prepareValueForComparison","length","caseRank","getCaseRanking","isPartial","isPartialOfCase","isCasedAcronym","isCaseAcronym","toLowerCase","indexOf","getAcronym","getClosenessRanking","string","acronym","wordsInString","split","forEach","wordInString","splitByHyphenWords","splitByHyphenWord","substr","containsUpperCase","containsDash","containsUnderscore","startsWithUpperCase","toUpperCase","caseRanking","testIndex","splitValue","splitTestString","correct","char","charIndex","splitItem","matchingInOrderCharCount","charNumber","findMatchingCharacter","matchChar","j","stringChar","getRanking","spread","inOrderPercentage","ranking","firstIndex","found","a","b","aFirst","bFirst","aRankedItem","aRank","aKeyIndex","bRankedItem","bRank","bKeyIndex","String","localeCompare","_ref4","keepDiacritics","getItemValues","key","itemObj","nestedKey","concat","allVals","values","getKeyAttributes","Infinity"],"sources":["/home/jose-daniel/Área de Trabalho/projeto-web/order-easy/node_modules/match-sorter/dist/match-sorter.esm.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\n\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 9,\n  EQUAL: 8,\n  STARTS_WITH: 7,\n  WORD_STARTS_WITH: 6,\n  STRING_CASE: 5,\n  STRING_CASE_ACRONYM: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nvar caseRankings = {\n  CAMEL: 0.8,\n  PASCAL: 0.6,\n  KEBAB: 0.4,\n  SNAKE: 0.2,\n  NO_CASE: 0\n};\nmatchSorter.rankings = rankings;\nmatchSorter.caseRankings = caseRankings;\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // not performing any search/sort if value(search term) is empty\n  if (!value) return items;\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(sortRankedItems).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var _getHighestRanking = getHighestRanking(item, keys, value, options),\n        rankedItem = _getHighestRanking.rankedItem,\n        rank = _getHighestRanking.rank,\n        keyIndex = _getHighestRanking.keyIndex,\n        _getHighestRanking$ke = _getHighestRanking.keyThreshold,\n        keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;\n\n    if (rank >= keyThreshold) {\n      matches.push({\n        rankedItem: rankedItem,\n        item: item,\n        rank: rank,\n        index: index,\n        keyIndex: keyIndex\n      });\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedItem: item,\n      rank: getMatchRanking(item, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedItem = _ref2.rankedItem,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedItem = rankedItem;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedItem = itemValue;\n    }\n\n    return {\n      rankedItem: newRankedItem,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  /* eslint complexity:[2, 12] */\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  var caseRank = getCaseRanking(testString);\n  var isPartial = isPartialOfCase(testString, stringToRank, caseRank);\n  var isCasedAcronym = isCaseAcronym(testString, stringToRank, caseRank); // Lower casing before further comparison\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL + caseRank;\n  } // starts with\n\n\n  if (testString.indexOf(stringToRank) === 0) {\n    return rankings.STARTS_WITH + caseRank;\n  } // word starts with\n\n\n  if (testString.indexOf(\" \" + stringToRank) !== -1) {\n    return rankings.WORD_STARTS_WITH + caseRank;\n  } // is a part inside a cased string\n\n\n  if (isPartial) {\n    return rankings.STRING_CASE + caseRank;\n  } // is acronym for a cased string\n\n\n  if (caseRank > 0 && isCasedAcronym) {\n    return rankings.STRING_CASE_ACRONYM + caseRank;\n  } // contains\n\n\n  if (testString.indexOf(stringToRank) !== -1) {\n    return rankings.CONTAINS + caseRank;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).indexOf(stringToRank) !== -1) {\n    return rankings.ACRONYM + caseRank;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score base on the case of the testString\n * @param {String} testString - the string to test against\n * @returns {Number} the number of the ranking,\n * based on the case between 0 and 1 for how the testString matches the case\n */\n\n\nfunction getCaseRanking(testString) {\n  var containsUpperCase = testString.toLowerCase() !== testString;\n  var containsDash = testString.indexOf('-') >= 0;\n  var containsUnderscore = testString.indexOf('_') >= 0;\n\n  if (!containsUpperCase && !containsUnderscore && containsDash) {\n    return caseRankings.KEBAB;\n  }\n\n  if (!containsUpperCase && containsUnderscore && !containsDash) {\n    return caseRankings.SNAKE;\n  }\n\n  if (containsUpperCase && !containsDash && !containsUnderscore) {\n    var startsWithUpperCase = testString[0].toUpperCase() === testString[0];\n\n    if (startsWithUpperCase) {\n      return caseRankings.PASCAL;\n    }\n\n    return caseRankings.CAMEL;\n  }\n\n  return caseRankings.NO_CASE;\n}\n/**\n * Returns whether the stringToRank is one of the case parts in the testString (works with any string case)\n * @example\n * // returns true\n * isPartialOfCase('helloWorld', 'world', caseRankings.CAMEL)\n * @example\n * // returns false\n * isPartialOfCase('helloWorld', 'oworl', caseRankings.CAMEL)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Number} caseRanking - the ranking score based on case of testString\n * @returns {Boolean} whether the stringToRank is one of the case parts in the testString\n */\n\n\nfunction isPartialOfCase(testString, stringToRank, caseRanking) {\n  var testIndex = testString.toLowerCase().indexOf(stringToRank.toLowerCase());\n\n  switch (caseRanking) {\n    case caseRankings.SNAKE:\n      return testString[testIndex - 1] === '_';\n\n    case caseRankings.KEBAB:\n      return testString[testIndex - 1] === '-';\n\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      return testIndex !== -1 && testString[testIndex] === testString[testIndex].toUpperCase();\n\n    default:\n      return false;\n  }\n}\n/**\n * Check if stringToRank is an acronym for a partial case\n * @example\n * // returns true\n * isCaseAcronym('super_duper_file', 'sdf', caseRankings.SNAKE)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the acronym to test\n * @param {Number} caseRank - the ranking of the case\n * @returns {Boolean} whether the stringToRank is an acronym for the testString\n */\n\n\nfunction isCaseAcronym(testString, stringToRank, caseRank) {\n  var splitValue = null;\n\n  switch (caseRank) {\n    case caseRankings.SNAKE:\n      splitValue = '_';\n      break;\n\n    case caseRankings.KEBAB:\n      splitValue = '-';\n      break;\n\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      splitValue = /(?=[A-Z])/;\n      break;\n\n    default:\n      splitValue = null;\n  }\n\n  var splitTestString = testString.split(splitValue);\n  return stringToRank.toLowerCase().split('').reduce(function (correct, char, charIndex) {\n    var splitItem = splitTestString[charIndex];\n    return correct && splitItem && splitItem[0].toLowerCase() === char;\n  }, true);\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index; j < string.length; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1; i < stringToRank.length; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedItems(a, b) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRankedItem = a.rankedItem,\n      aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRankedItem = b.rankedItem,\n      bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // localeCompare returns 0 if both values are equal,\n      // so we rely on JS engines stably sorting the results\n      // (de facto, all modern engine do this).\n      return String(aRankedItem).localeCompare(bRankedItem);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item); // eslint-disable-next-line no-negated-condition\n  } else if (key.indexOf('.') !== -1) {\n    // handle nested keys\n    value = key.split('.').reduce(function (itemObj, nestedKey) {\n      return itemObj ? itemObj[nestedKey] : null;\n    }, item);\n  } else {\n    value = item[key];\n  } // concat because `value` can be a string or an array\n  // eslint-disable-next-line\n\n\n  return value != null ? [].concat(value) : null;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param {Object} item - the item from which the values will be retrieved\n * @param {Array} keys - the keys to use to retrieve the values\n * @return {Array} objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  return keys.reduce(function (allVals, key) {\n    var values = getItemValues(item, key);\n\n    if (values) {\n      values.forEach(function (itemValue) {\n        allVals.push({\n          itemValue: itemValue,\n          attributes: getKeyAttributes(key)\n        });\n      });\n    }\n\n    return allVals;\n  }, []);\n}\n/**\n * Gets all the attributes for the given key\n * @param {Object|String} key - the key from which the attributes will be retrieved\n * @return {Object} object containing the key's attributes\n */\n\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    key = {\n      key: key\n    };\n  }\n\n  return _extends({\n    maxRanking: Infinity,\n    minRanking: -Infinity\n  }, key);\n}\n\nexport default matchSorter;\nexport { rankings };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}